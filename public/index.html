<!DOCTYPE html>
<html>
  <head>
    <title>ADXL345 3D Orientation</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #000;
      }
    </style>
  </head>
  <body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script>
      const socket = io();

      // Scene setup
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(3, 2, 5);
      camera.lookAt(0, 0, 0);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Lighting
      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(5, 10, 7.5);
      scene.add(light);

      const gridHelper = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
      scene.add(gridHelper);
      
      // Axes Helper
      const axesHelper = new THREE.AxesHelper(2);
      scene.add(axesHelper);

      // Cube
      const geometry = new THREE.BoxGeometry(1, 1, 1);
      const material = new THREE.MeshNormalMaterial();
      const cube = new THREE.Mesh(geometry, material);
      scene.add(cube);

      // Smoothing state
      let targetRotation = { x: 0, y: 0 };
      let currentRotation = { x: 0, y: 0 };
      const smoothingFactor = 0.1;

      // Receive real-time data
      socket.on("sensor-data", ({ pitch, roll }) => {
        targetRotation.x = THREE.MathUtils.degToRad(pitch);
        targetRotation.y = THREE.MathUtils.degToRad(roll);
      });

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);

        // Smooth rotation with interpolation
        currentRotation.x +=
          (targetRotation.x - currentRotation.x) * smoothingFactor;
        currentRotation.y +=
          (targetRotation.y - currentRotation.y) * smoothingFactor;

        cube.rotation.x = currentRotation.x;
        cube.rotation.y = currentRotation.y;

        renderer.render(scene, camera);
      }

      animate();
    </script>
  </body>
</html>
